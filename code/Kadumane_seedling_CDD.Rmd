---
title: "Density-dependence seedling mortality in Kadumane"
author: "Robert Bagchi and Ashwin Viswanathan"
date: "`r format(Sys.time(), '%d %B %Y')`"
graphics: yes
output: 
  pdf_document:
    number_sections: yes
    toc: true
  github_document:
    toc: yes
  
---
## set up

```{r load_packages, message=FALSE}
library(tidyverse)
library(ggthemes)
library(knitr)
library(glmmTMB)
library(DHARMa)
library(broom.mixed)
library(ggeffects)
library(ggdist)
library(sjPlot)
library(patchwork)
```

```{r graphic_setup}
theme_set(theme_tufte())
```

# Data 

Load data

```{r load_data}
sp_codes <- read_csv("data/sp_codes.csv")
site_dat <- read_rds("data/kadumane_site_metadata.rds")
sdls <- read_rds("data/kadumane_seedlings.rds")
plot_dat <- read_rds("data/kadumane_plot_metadata.rds")

```

1. Join in site and plot meta-data.

2. Remove rows for species with no seedlings at start of the census in plot.

3. Select species that 
* Are recorded in at least 5 plots.
* Vary in density among plots.
* Are groups of many (unidentified) species with the same code.

```{r select_species, cache = TRUE}
sdls |> summarise(n_sdls = sum(census.start), 
                  n_survs = sum(census.final),
                  n_species = n_distinct(species)) |> knitr::kable()

sdls <-  sdls |> left_join(site_dat) |> left_join(plot_dat) |> 
  filter(census.start > 0)

## find species with enough individuals and variation in density to allow 
## analysis
sp_list <- group_by(sdls, species) |> 
  summarise(abund = sum(census.start) ,  ## total abund
            n = sum(census.start > 0), ## number of plots withe species
            sd_dens = sd(census.start[census.start > 0])) |> ##var in density
  filter(n > 1) |> arrange(n)
## only lose 8 species by restricting to 5 or more occurrences (instead of 1)
## Seems reasonable. Also removing species that were unreliably identified.

sp_list <- filter(sp_list, n > 4, !(species %in% c("Palm", "Artoh", "SC")),
                  sd_dens > 0) 
sdls <- filter(sdls, species %in% sp_list$species)
dim(sdls) ## 968 columns

# Number of plots= 37 locs * 3 groups * 5 plots
n_plots <- 37*3*5
n_sites <- 21
```

Rename columns, add total seedling density, scale and centre data.

```{r data_wrangling, cache = TRUE}
## shorten names
sdls <- rename(sdls, 
               "trt_F" = "treatment.fungicide", 
               "trt_I" = "treatment.insecticide", 
               "Pr_m" = "proportion.mortality",
               "gr" = "group",## group causes problems with some helper funcs
               "loc" = "location") 
## categorical variable for treatment
sdls <- mutate(sdls, trt = case_when(
  trt_F == "0" & trt_I == "0" ~ "C",
  trt_F == "F" & trt_I == "0" ~ "F",
  trt_F == "0" & trt_I == "I" ~ "I",
  trt_F == "F" & trt_I == "I" ~ "FI"),
  trt = factor(trt, levels = c("C", "I", "F", "FI")))

## add total density
tot_dens <- sdls |> group_by(site, loc, gr, plot) |> 
  summarise(tot_dens = sum(census.start))

## add species mean density
## divide by total number of plots
sp_mean_dens <- sdls |> group_by(species) |> 
  summarise(sp_mean_condens = sum(census.start)/n_plots, 
            sp_mean_surv = sum(census.final)/sum(census.start))

sdls <- left_join(sdls, tot_dens, by = c("site", "loc", "gr", "plot")) |> 
  left_join(select(sp_mean_dens, - sp_mean_surv))

#scale density by mean, fix couple of NAs
sdls <- mutate(sdls, 
               slope.degrees = replace_na(slope.degrees, 5), 
               Pr_s = 1 - Pr_m,
               con_dens = census.start,
               con_dens_s = con_dens/sp_mean_condens,
               slope.degrees_s = as.vector(scale(slope.degrees)),
                trt_F = factor(trt_F, labels = c("0", "F")),
                trt_I = factor(trt_I, labels = c("0", "I"))
               )

## calculate total scaled density. Note this is the sum of the scaled densities
## of all species in the plot. Remember that the total_density contrast only 
## works when all conspecific densities sum to total density (replicating 
## a sum-to-zero contrast for conspecific and heterospecific densities.
sdls <- left_join(sdls, 
                  group_by(sdls, site, loc, gr, plot) |> 
                    summarise(tot_dens_s = sum(con_dens_s)))
summary(sdls)


dim(sdls) ## 968 species x plot combinations
```


# Summary information for the paper
```{r summary_info}
sdls |> summarise(n_sdls = sum(census.start), 
                  n_survs = sum(census.final),
                  n_species = n_distinct(species)) |> knitr::kable()
sdls <- droplevels(sdls)
table(sdls$species)[order(table(sdls$species))]
```


# Models

## Scaled conspecific density models

The most abundant species initially will often have lower survival (fecundity/
survival trade-off). This could generate what looks like a density-dependent 
relationship when looking across species, even without a relationship 
within species (i.e., Simpson's paradox). 

```{r abundance_survival}
ggplot(sp_mean_dens, aes(x = log(sp_mean_condens), y = sp_mean_surv)) +
  geom_label(aes(label= species)) + geom_smooth(method = "lm") + theme_tufte()

## not the clearest pattern, but worth accounting for.
(ggplot(sdls, aes(x = scale((con_dens_s)), colour = species)) + geom_density())/
(ggplot(sdls, aes(x = scale((con_dens)), colour = species)) + 
   geom_density()) + plot_layout(guides = "collect")
```

To account for this, we can scale conspecific density by dividing by mean
density and refitting the models.

```{r fit_models, cache = TRUE}

## Random intercept model
m_cdd_s_ri <- glmmTMB(Pr_s ~ slope.degrees_s + 
                        trt_I:trt_F +
                         (scale(tot_dens_s) + scale(con_dens_s)) *
                         (trt_I + trt_F) *
                         scale(fragment.size)  +
                        (1|species) +
                        (1|site/loc/gr/plot), 
                      weights = census.start, data = sdls, 
                      family=binomial)

## Random intercept and slope model for species specific effects
m_cdd_s_ris <- glmmTMB(Pr_s ~ slope.degrees_s + 
                         trt_I:trt_F +
                         (scale(tot_dens_s) + scale(con_dens_s)) *
                         (trt_I + trt_F) *
                         scale(fragment.size)  +
                         (scale(con_dens_s) + scale(tot_dens_s)|species) +
                         (1|site/loc/gr/plot), 
                       weights = census.start, 
                       data = sdls, 
                       family=binomial)
## note the slightly odd ordering of terms doesn't change the model structure,
## but does change the default ordering of terms in outputs and plots to a
## more convenient one for describing in paper (first CDD, then biocide effects
## then fragmentation effects).

anova(m_cdd_s_ri, m_cdd_s_ris) ## random slope *much* better

```

Models fit without issues, even with the correlation among density effects. 

The improvement with the random slopes model suggests we need to look at 
individual species. Proceeding with the random intercept and slope model from
here on.

### Diagnostics

```{r diag_scaled, cache = TRUE}
res_s <- simulateResiduals(m_cdd_s_ris)
plot(res_s) ## ok - some deviation from ideal residual distribution, but 
## acceptable.

## look at relationship with covariates
diag_dat <- data.frame(m_cdd_s_ris$frame, res = res_s$fittedResiduals)

diag_dat <-   rename_with(diag_dat, ~ str_replace(.x, "scale\\.", "")) |> 
  rename_with(~str_replace(.x, "\\.$", "")) 

ggplot(diag_dat, aes(x = con_dens_s, y = res)) +  
  geom_point(aes(colour = species)) + 
  geom_hline(yintercept=0, linetype = "dashed") +
  geom_smooth(method="gam") ## no trend. 

ggplot(diag_dat, aes(x = fragment.size, y = res)) +  
  geom_point(aes(colour = species), position = "jitter") + 
  geom_hline(yintercept=0, linetype = "dashed") +
  geom_smooth(method="gam") ## no trend. 

ggplot(diag_dat, aes(x = con_dens_s, y = res)) +  
  facet_wrap(~trt_F + trt_I ) +
  geom_point(aes(colour = species)) +
  geom_smooth(method="gam") ## no trend with treatment

```

The diagnostics aren't perfect, but not particularly unusual for a binomial
model. None of the big problems (e.g., overdispersion, trends with 
covariates) seem to apply here.

### Model inference

```{r inference_scaled, cache = TRUE}
summary(m_cdd_s_ris)
plot_model(m_cdd_s_ris, show.values=TRUE) + ylim(c(0.2, 3)) 

plot_model(m_cdd_s_ris, show.values=TRUE) + ylim(c(0.2, 3)) 


## total density is never very important, so separating out it's effects
rmvars <- names(fixef(m_cdd_s_ris)$cond)
rmvars <- c(rmvars[grep("tot_dens_s", rmvars)], "slope.degrees_s")

## First confirm it isn't influential
plot_model(m_cdd_s_ris, show.values=TRUE, terms=rmvars) + ylim(c(0.2, 3)) 
# basically what we thought

## now decluttered version
plot_model(m_cdd_s_ris, show.values=TRUE, rm.terms=rmvars) + ylim(c(0.2, 3)) 

## compare to random intercept model

plot_models(m_cdd_s_ri, m_cdd_s_ris, rm.terms=rmvars, m.labels=c("ri", "ris"),
            p.shape = TRUE)

summary(m_cdd_s_ri)

```

### Take-homes:

* Survival is negatively conspecific density dependent. This result is
consistent across all permutations of the model tried.

* Insecticide and fungicide (to a lesser extent) increase survival significantly.

* Fungicide removes the CDD, and that effect strengthens with fragment area. 
However, that effect needs more exploration (see below).

* The interaction between CDD and fragment size is complex, but perhaps
explained by species turnover. The CDD effect strengthens with fragment area, 
but not significantly (or even close) in the (better) random slope model. 
In the random intercept model, the relationship is significant. This is 
probably because of species turnover - perhaps species that prefer
larger fragments happen to be ones that show stronger density dependence?


* Effects of  fragment area and any interactions with density
need more probing as the effects are sensitive to model structure.


### Models split by categorical fragment size 

The effect of fragment

```{r mod_by_fragsize, cache = TRUE}
# Using 3 categories
sdls <- mutate(sdls, 
               frag_sizeclass3 = cut(fragment.size, 
                                     round(quantile(site_dat$fragment.size, 
                                              c(0, 0.33, 0.66, 1))), 
                                        include.lowest=TRUE))

## quick look at how many fragments and seedlings within each 
## fragment size category

sdls |> group_by(frag_sizeclass3) |> summarise(n_frag = n_distinct(site),
                                               n_sdl = n())

m_cdd_s_ris_frag3 <- lapply(split(sdls, f= sdls$frag_sizeclass3), function(d){
  var_d <- d |> group_by(species) |> 
    summarise(var_dens = var(con_dens_s)) |> 
    filter(!is.na(var_dens) & var_dens > 0) 
  
  glmmTMB(Pr_s ~ slope.degrees_s + 
            trt_I:trt_F +
            (scale(tot_dens_s) + scale(con_dens_s)) *
            (trt_I + trt_F) +
            (scale(con_dens_s) + scale(tot_dens_s)||species) +
            (1|site/loc/gr/plot), 
          weights = census.start, 
          data = filter(d, species %in% var_d$species), 
          family=binomial)})

## can probably ignore the warning, which comes from the random 
## effect structure and tiny variances. We don't want to remove it because
## that would hamper comparison.

#diagnose(m_cdd_s_ris_frag3[[2]])

term_nms <- names(fixef(m_cdd_s_ris_frag3[[1]])$cond) 
names(m_cdd_s_ris_frag3) <- c("1 - 4", "5 - 32", "33 - 150") ## renaming to

## be clearer and correct (from looking at observed boundaries)
plot_discrete <- plot_models(m_cdd_s_ris_frag3, 
            rm.terms=c("slope.degrees_s", 
            term_nms[str_detect(term_nms, "tot")]), ## declutter
            m.labels=names(m_cdd_s_ris_frag3), p.shape=TRUE, 
            show.values = TRUE) +
  labs(colour = "Fragment Area")

pl_discrete <- plot_discrete$data |> 
  mutate(term = str_replace_all(term, fixed("scale(con_dens_s)"),"ConDens"),
         term = str_replace_all(term, "trt_[FI]", ""),
         term = factor(term, levels = rev(unique(term))), 
         FragArea = factor(group, levels = c("1 - 4", "5 - 32", "33 - 150")))

pl_discrete <- ggplot(pl_discrete, aes(x = estimate, xmin = conf.low, xmax = conf.high, 
                         y = term, colour = FragArea)) + 
  geom_pointrange(position = position_dodge2(width = 0.3)) +
  geom_vline(xintercept=1, linetype = "dotted") +
  scale_x_continuous(trans = "log10", n.breaks = 7) +
  scale_colour_viridis_d(option="D", end=0.8) +
  labs(x = "log(odds ratio)", y = NULL, colour = "Fragment\nArea (ha)")

pl_discrete

ggsave(pl_discrete, file = "figures/CatFragPlot.png", height = 5, width = 5)

map(m_cdd_s_ris_frag3, summary)

```

### Take-homes

The model gets a bit complex when split like this, but it serves as a useful
exploration of what's going on. 

* Conspecific density reduces survival most clearly in the larger fragments.

* The results of fungicide:cdens make a bit more sense when the data
are broken up like this. Fungicide only interacts with cdens in the largest 
fragments, which makes sense, because these are the fragments where cdens has an
effect.

* insects seem to only reduce plant survival in the medium and large fragments

### Graphics

```{r plots_scaled, cache = TRUE}
## refitting model to control order of coefficients
m_cdd_s_ris <- glmmTMB(Pr_s ~ slope.degrees_s +
                         (scale(tot_dens_s) + scale(con_dens_s)) +
                         scale(fragment.size) +
                         trt_I*trt_F +
                         (scale(tot_dens_s) + scale(con_dens_s)) *
                         (trt_I + trt_F) *
                         scale(fragment.size)  +
                         (scale(con_dens_s) + scale(tot_dens_s)|species) +
                         ## setting cor to 0 to converge
                         (1|site/loc/gr/plot),
                       weights = census.start,
                       data = sdls,
                       family=binomial)
fixef(m_cdd_s_ris)

labs <-  c("ConDens","FragArea", "I", "F",  "I:F", 
           "ConDens:I", "ConDens:F", "FragArea:\n ConDens", 
           "FragArea:I" , "FragArea:F", 
           "FragArea:\n (ConDens:I)", "FragArea:\n (ConDens:F)")

tp_cdd_s_ris <- 
  tidy(m_cdd_s_ris, conf.int = TRUE) |> 
  filter(effect == "fixed", 
         !str_detect(term, "tot_dens"), 
         !term %in% c("(Intercept)", "slope.degrees_s")) |> 
  mutate(labels = factor(labs, levels = rev(labs)), 
         Biocide = case_when(
           str_detect(term, "trt_II") ~  "Insecticide",
           str_detect(term, "trt_FF") ~ "Fungicide",
           .default =  "Control"),
         Biocide = factor(ifelse(str_detect(term, "trt_II:trt_FF"),
                                 "Both", Biocide), 
                          levels = c("Control", "Insecticide", 
                                     "Fungicide", "Both"))) |> 
  ggplot(aes(y = labels, x = estimate, xmin = conf.low, xmax = conf.high, 
             colour = Biocide)) + 
  geom_pointrange(aes(shape = p.value < 0.05 )) +
  geom_vline(xintercept=0, linetype = "dotted") +
  scale_colour_brewer(palette="Set2") +
  scale_shape_manual(values=c(1, 16), guide = "none" ) +
  labs(y = NULL, x = "log(odds ratio)")  + 
  guides(colour = guide_legend(title= "Biocide:", position = "top", 
                               direction = "horizontal", 
                               title.position = "left", title.hjust = 0.5)) +
  theme(
    legend.margin = margin(0, 0, 0, 0), 
    legend.justification.top = "left",
    legend.location = "plot",
    plot.title.position = "plot"
  )                                        
tp_cdd_s_ris

p_cdd_s_ris <- predict_response(m_cdd_s_ris, 
                                terms=c("con_dens_s[1:80, by = 1]", 
                                        "trt_I", "trt_F",
                                        "fragment.size[5, 65, 125]"))

pr_cdd_s_ris <- residualize_over_grid(p_cdd_s_ris, m_cdd_s_ri) |> 
  bind_cols(species = sdls$species) |> 
  mutate(trt = factor(
    case_when(
      group == "0" & facet == "0" ~ "Control",
      group == "0" & facet == "F" ~ "Fungicide",
      group == "I" & facet == "0" ~ "Insecticide",
      group == "I" & facet == "F" ~ "Both"),
    levels = c("Control", "Insecticide", "Fungicide", "Both")),
    facet_lab = "Fragment Area (ha)") |> 
  rename("con_dens" = "x", "frag_area" = "panel") |> 
  group_by(con_dens, trt, frag_area, facet_lab, species) |> 
  summarise(predicted = mean(predicted), n = n())

p_cdd_s_ris <- as.data.frame(p_cdd_s_ris) |> 
  mutate(trt = factor(
    case_when(
      group == "0" & facet == "0" ~ "Control",
      group == "0" & facet == "F" ~ "Fungicide",
      group == "I" & facet == "0" ~ "Insecticide",
      group == "I" & facet == "F" ~ "Both"),
    levels = c("Control", "Insecticide", "Fungicide", "Both")),
    facet_lab = "Fragment Area (ha)") |> 
  rename("con_dens" = "x", "frag_area" = "panel")

# summary(p_cdd_s_ris)
# summary(pr_cdd_s_ris)

pl_cdd_s <- ggplot(p_cdd_s_ris, 
       aes(x=con_dens, y = predicted, colour = trt)) +
  ggh4x::facet_nested(~facet_lab + frag_area) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high, fill = trt), 
              colour = NA, alpha = 0.3) + 
  geom_line(linewidth = 1.2) +
  geom_point(data = pr_cdd_s_ris) +
  scale_colour_brewer(palette="Set2") + 
  scale_fill_brewer(palette="Set2", guide = "none") +
  labs(x = expression(Conspecific~density~(m^-2)), y = "Pr(Survival)", 
       colour = "Treatment") + theme(legend.position="none")

mod_plot <- (pl_cdd_s  | tp_cdd_s_ris )  + 
  plot_layout(widths=c(0.6, 0.4))
mod_plot

# the predictions with the "both" treatment get really busy. Given the 
# lack of an interaction, trying without both

pl_cdd_s_2 <- ggplot(filter(p_cdd_s_ris, trt != "Both"), 
       aes(x=con_dens, y = predicted, colour = trt)) +
  ggh4x::facet_nested(~facet_lab + frag_area) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high, fill = trt), 
              colour = NA, alpha = 0.3) + 
  geom_line(linewidth = 1.2) +
  geom_point(data = filter(pr_cdd_s_ris, trt != "Both")) +
  scale_colour_brewer(palette="Set2") + 
  scale_fill_brewer(palette="Set2", guide = "none") +
  labs(x = expression(Conspecific~density~(m^-2)), y = "Pr(Survival)", 
       colour = "Treatment") + theme(legend.position="none")

mod_plot2 <- (pl_cdd_s_2  | tp_cdd_s_ris )  + 
  plot_layout(widths=c(0.6, 0.4)) + plot_annotation(tag_level = "A") ## better
mod_plot2
ggsave(mod_plot2, file = "figures/model_results.png", height = 5.5, width = 7.5)
```


### Plotting effects of  fragment area

The effects are complex and hinge on a non-significant interaction between
fragment area and the fungicide effect. To interrogate them more, 
here are some plots (basically Neyman-Johnson interaction plots)

```{r fragarea_plots, cache = TRUE}
## plot the effect of density over fragment size
## helps to scale and log data outside the model formula to set this up
int_data <- sdls |> 
  mutate(con_dens_ss = scale(con_dens_s),
         tot_dens_ss = scale(tot_dens_s),
         fragsize_s = scale(fragment.size))

int_mod <- glmmTMB(Pr_s ~ slope.degrees_s + 
                     trt_I:trt_F +
                     (tot_dens_ss + con_dens_ss) *  
                     (trt_I + trt_F) * fragsize_s +
                     (1 + tot_dens_ss + con_dens_ss | species) +  
                     (1 | site/loc/gr/plot), 
                   weights = census.start, family = binomial, 
                   data = int_data)

preddat <- expand.grid(
  trt_F = levels(int_data$trt_F),
  trt_I = levels(int_data$trt_I),
  con_dens_ss = 1,
  fragsize_s = seq(-1, 2.1, length = 20)) |> 
  filter(!(trt_F == "F" & trt_I == "I"))

xmat <- model.matrix(~ con_dens_ss + con_dens_ss:(trt_F + trt_I + fragsize_s) +
                       con_dens_ss:trt_F:fragsize_s + 
                       con_dens_ss:trt_I:fragsize_s,
                     preddat)[ , -1]

preddat$int_hat <- as.vector(xmat %*% fixef(int_mod)$cond[colnames(xmat)])
vmat <- (vcov(int_mod)$cond[colnames(xmat), colnames(xmat)])
preddat$int_se <-  sqrt(diag(xmat %*% vmat %*% t(xmat)))

preddat <- preddat |> mutate(.lower = int_hat - 1.96*int_se, 
                             .upper = int_hat + 1.96*int_se, 
                             frag_area = fragsize_s*
                               sd(sdls$fragment.size) +
                               mean(sdls$fragment.size),
                             trt = factor(case_when(
                               trt_F == "0" & trt_I == "0" ~ "Control",
                               trt_F == "F" & trt_I == "0" ~ "Fungicide",
                               trt_F == "0" & trt_I == "I" ~ "Insecticide")))

int_plot <- ggplot(preddat, aes(x = frag_area)) + facet_wrap( ~ trt) + 
  geom_ribbon(aes(y = int_hat, ymin = .lower, ymax = .upper),
              alpha = 0.2, colour = NA) +
  geom_line(aes(y = int_hat)) + geom_hline(yintercept=0, linetype = "dotted") +
  labs(x =  "Fragment area (ha)", 
       y = "Effect of conspecific density on survival")


sdls <- mutate(sdls, trt = case_when(
  trt_F == "F" ~ "F",
  trt_I == "I" ~ "I",
  .default = "C"), 
  trt = factor(trt, labels = c("Control", "Fungicide", "Insecticide")))

int_plot <- int_plot + 
  ggdist::geom_dots(data = sdls, aes(x = fragment.size), y =  -2.8,
                    smooth = ggdist::smooth_unbounded(), layout = "swarm", 
                    side = "top", binwidth = 1,# alpha = 0.7, 
                    overflow = "compress")
int_plot
ggsave(int_plot, file = "figures/interaction_plot.png", width=6.6, height = 4)

```


## Species specific inferences.

Initial analyses suggested that some species were heavily influencing the results. 

The random slope should partly account for that.

```{r species_effects}
sjPlot::plot_model(m_cdd_s_ris, type = "re", terms = "species", ri.nr = 1)
## observable variation among species in CDD slopes, but not in tot_dens_s
sp_eff <- as.data.frame(ranef(m_cdd_s_ris, condVar = T)$cond$species)

sp_eff <- bind_cols(sp_eff, 
                    t(apply(attr(sp_eff, "condVar"), 3, function(x)
                      sqrt(diag(x)))))
names(sp_eff) <- c("Intercept", "con_dens", "tot_dens", 
                   "Intercept_se", "con_dens_se", "tot_dens_se")

## extract total effects
sp_eff <- mutate(sp_eff, sp_names = row.names(sp_eff),
                 Intercept = Intercept + fixef(m_cdd_s_ris)$cond[1],
                 con_dens = con_dens +
                   fixef(m_cdd_s_ris)$cond["scale(con_dens_s)"],
                 tot_dens = tot_dens +
                   fixef(m_cdd_s_ris)$cond["scale(tot_dens)"])

sp_eff <- left_join(sp_eff, sp_codes, by = c("sp_names" = "code"))
## wrangle species names
sp_eff <- sp_eff |> mutate(spbin = case_when(
  genus %in% c("Unidentified", "Meliac")   ~ paste(genus, species, sep = "~"),
  genus != "Unidentified" & str_starts("sp", species) ~ 
                    paste(paste0("italic('", genus, "')"), species, sep = "~"),
  .default =    paste0("italic('", paste(genus, species, sep = " "), "')")))

blup_plot <- sp_eff |> arrange(con_dens) |> 
  ggplot(aes(y = reorder(spbin, con_dens), x = con_dens, 
             xmin = con_dens - 2*con_dens_se, 
             xmax = con_dens + 2*con_dens_se)) +
    geom_vline(xintercept=0, linetype = "dotted") +
  geom_pointrange() + 
  scale_y_discrete(labels = scales::label_parse()) +
  labs(x = "Conspecific density effect", y = "Species")

blup_plot <- blup_plot + theme(axis.text.y = element_text(size = 7))
blup_plot
# ggsave(blup_plot, file = "figures/cdd_blups.png", width = 4, height =5)

anova(m_cdd_s_ris, m_cdd_s_ri)
```


Substantial variation in cdd among species - 


Perhaps remove most abundant species to check if patterns are robust.

```{r species_influence}
sdls |> group_by(species) |> summarise(n = sum(census.start)) |> 
   arrange(desc(n)) |> print(n = 26)


sp_common <- sdls |> group_by(species) |> summarise(n = sum(census.start)) |> 
   arrange(desc(n)) |> pull(species)
sp_mods <- lapply(c("none", as.character(sp_common[1:5])), function(i) {
  update(m_cdd_s_ris, data = filter(sdls, !species == i))})

sp_codes <- mutate(sp_codes, spbin = paste(genus, species))
term_nms <- names(fixef(sp_mods[[1]])$cond)
names(sp_mods) <- c("None", as.character(sp_common[1:5]))
plot_models(sp_mods,
            rm.terms = c("slope.degrees_s", 
                         term_nms[str_detect(term_nms, "tot")]),
            m.labels = c("None", 
                         sp_codes$spbin[match(sp_common[1:5], sp_codes$code)]),
            p.shape=TRUE) + labs(colour = "Species excluded") +
  scale_color_viridis_d(end=0.9) ## getting rid of the awful yellow.
map(sp_mods, summary)

```

Only species that makes a difference is S. rubicundum - removing it dampens interaction between density and fungicide (it is still there, but marginally non-significant)


what about single species models?
```{r single_sp}
## base model.
## remove species random effect
names(sp_common) <- sp_common
single_sp_mods <- map(sp_common[1:5], function(i) {
  glmmTMB(Pr_s ~  slope.degrees_s +
            (scale(tot_dens_s) + scale(con_dens_s)) +
            scale(fragment.size) +
            trt_I*trt_F +
            (scale(tot_dens_s) + scale(con_dens_s)) *
            (trt_I + trt_F) *
            scale(fragment.size)  +
            ## setting cor to 0 to converge
            (1|site/loc/gr/plot), 
          weights = census.start, 
          data = filter(sdls, species == i), 
          family=binomial)})
 
names(single_sp_mods) <- 
  sp_codes$spbin[match(names(single_sp_mods), sp_codes$code)]
single_sp_mods$All <- m_cdd_s_ris

map(single_sp_mods, summary)

term_nms <- names(fixef(single_sp_mods[[1]])$cond)

plot_models(single_sp_mods, m.labels=names(single_sp_mods), p.shape=TRUE, 
                        rm.terms = c("slope.degrees_s", 
                         term_nms[str_detect(term_nms, "tot")])) +
  scale_colour_viridis_d(end=0.9, name="Species", option="H")

## Ventilago distorts scale, so dropping it
plot_models(single_sp_mods[-4], m.labels=names(single_sp_mods)[-4],
            p.shape=TRUE, 
            rm.terms = c("slope.degrees_s", 
                         term_nms[str_detect(term_nms, "tot")])) +
  scale_colour_viridis_d(end=0.9, name="Species", option="H")

## As convenient as the plot_models function is, it would be nice to 
## plot different species on different scales and simplify the 
## p-values

sp_effects <- map(single_sp_mods, \(d) {
  tidy(d, conf.int = TRUE ) |>  
  filter(effect == "fixed", str_detect(term, "tot", negate=TRUE),
         !(term %in% c("(Intercept)", "slope.degrees_s") )) 
}) |> bind_rows(.id = "Species")

labs <- data.frame(par = c("ConDens","FragArea", "I", "F",  "I:F", 
           "ConDens:I", "ConDens:F", "FragArea:\n ConDens", 
           "FragArea:I" , "FragArea:F", 
           "FragArea:\n (ConDens:I)", "FragArea:\n (ConDens:F)"),
           term = unique(sp_effects$term)) |> 
  mutate(par = factor(par, levels = rev(par)))


sp_effects <- left_join(sp_effects, labs, by = "term")

sp_effects <- mutate(sp_effects, 
                     Biocide = case_when(
                       str_detect(term, "trt_II") ~  "Insecticide",
                       str_detect(term, "trt_FF") ~ "Fungicide",
                       .default =  "Control"),
                     Biocide = factor(
                       ifelse(str_detect(term,"trt_II:trt_FF"), 
                              "Both", Biocide), 
                       levels = c("Control", "Insecticide", 
                                  "Fungicide", "Both")))
sp_effects <- sp_effects |> mutate(sp_effects, 
                                   Species = ifelse(Species == "All", "All", 
                                      paste0("italic('", Species, "')")))

pl_species <-
  filter(sp_effects, Species != "All", par != "I:F") |> 
  ggplot(aes(x = estimate, xmin = conf.low, xmax = conf.high, 
             y = par, colour = Biocide)) +
           facet_wrap(~Species, scales = "free_x", labeller = label_parsed) +
  geom_pointrange(aes(shape = p.value < 0.05 )) +
  geom_vline(xintercept=0, linetype = "dotted") +
  scale_colour_brewer(palette="Set2") +
  scale_shape_manual(values=c(21, 16), guide = "none" ) +
  labs(y = NULL, x = "log(odds ratio)") 

# lemon::reposition_legend(pl_species, position = 'top right',
#                                        panel='panel-3-2')


# ggsave(lemon::reposition_legend(pl_species, position = 'top right',
#                                        panel='panel-3-2'),
#        file = "figures/species_plot.png", height = 7, width = 7)

pl_species <- ((blup_plot) |
                  (pl_species + theme(legend.position = c(0.95, 0.05), 
                                      legend.justification=c(1, 0)))) + 
  plot_layout(widths=c(0.35, 0.65)) + plot_annotation(tag_levels = "A")
pl_species
ggsave(pl_species,
       file = "figures/species_plot.png", height = 7, width = 9)

```


# Session Information

```{r sessioninfo}
sessionInfo()
```